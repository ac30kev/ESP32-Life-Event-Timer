#include <WiFi.h>
#include <esp_now.h>
#include <FastLED.h>

// ‚Äî‚Äî‚Äî CONFIG ‚Äî‚Äî‚Äî
#define DATA_PIN 4
#define NUM_LEDS 17
#define COLOR_ORDER GRB
#define CHIPSET WS2812B

// ESP-NOW sender MAC(s) (fill in your bell-push ESP32 here)
static const uint8_t bellSenderMAC[][6] = {
  { 0xE8, 0x6B, 0xEA, 0xDE, 0xAB, 0x04 }
};
const size_t NUM_SENDERS = sizeof(bellSenderMAC) / sizeof(bellSenderMAC[0]);

// Override timing
const unsigned long OVERRIDE_DURATION = 10000;  // 10 s total
const unsigned long FLASH_INTERVAL = 500;       // 0.5 s on/off

// Breathing timings (seconds)
const float BREATH_UP_SEC = 3.0;
const float BREATH_HOLD_HI = 2.0;
const float BREATH_DOWN_SEC = 4.0;
const float BREATH_HOLD_LO = 1.0;
const uint8_t BREATH_MIN = 20;  // never fully off
const uint8_t BREATH_MAX = 180;

// ‚Äî‚Äî‚Äî STATE ‚Äî‚Äî‚Äî
CRGB leds[NUM_LEDS];

bool overrideActive = false;
unsigned long overrideStartTime = 0;
unsigned long lastFlashToggle = 0;
bool flashOn = false;

// Breathing state
unsigned long breathStart = 0;
uint8_t breathPhase = 0;  // 0=up,1=hold_hi,2=down,3=hold_lo

// ‚Äî‚Äî‚Äî ESP-NOW CALLBACK ‚Äî‚Äî‚Äî
void onBellRecv(const esp_now_recv_info_t* info, const uint8_t* data, int len) {
  // check sender
  for (size_t i = 0; i < NUM_SENDERS; i++) {
    if (memcmp(info->src_addr, bellSenderMAC[i], 6) == 0) {
      if (len >= 4 && memcmp(data, "bell", 4) == 0) {
        Serial.println("üîî bell message received");
        overrideActive = true;
        overrideStartTime = millis();
        lastFlashToggle = 0;
        flashOn = false;
      }
      break;
    }
  }
}

// ‚Äî‚Äî‚Äî SETUP ‚Äî‚Äî‚Äî
void setup() {
  Serial.begin(115200);
  delay(100);
  WiFi.mode(WIFI_STA);
  delay(50);
  
  // Print own MAC
  Serial.print("Heltec MAC Address: ");
  Serial.println(WiFi.macAddress());

  // FastLED init
  FastLED.addLeds<CHIPSET, DATA_PIN, COLOR_ORDER>(leds, NUM_LEDS);
  FastLED.clear();
  FastLED.show();

  // ESP-NOW init

  WiFi.disconnect();
  if (esp_now_init() != ESP_OK) {
    Serial.println("‚ùå ESP-NOW init failed");
    while (true) delay(1000);
  }
  esp_now_register_recv_cb(onBellRecv);

  // register senders as peers (optional for receive-only, but safe)
  for (size_t i = 0; i < NUM_SENDERS; i++) {
    esp_now_peer_info_t peer = {};
    memcpy(peer.peer_addr, bellSenderMAC[i], 6);
    peer.channel = 0;
    peer.encrypt = false;
    esp_now_add_peer(&peer);
  }

  // start breathing
  breathStart = millis();
  Serial.println("‚úÖ Bell‚Äâ&‚ÄâBreathe ready");
}

// ‚Äî‚Äî‚Äî HELPERS ‚Äî‚Äî‚Äî
// Linear interpolation
uint8_t lerp8(uint8_t a, uint8_t b, float t) {
  return a + (b - a) * t;
}

void doBreathing() {
  unsigned long now = millis();
  float cycleDur = BREATH_UP_SEC + BREATH_HOLD_HI + BREATH_DOWN_SEC + BREATH_HOLD_LO;
  float t = fmod((now - breathStart) / 1000.0, cycleDur);

  float v;
  if (t < BREATH_UP_SEC) {
    // ramp up
    v = t / BREATH_UP_SEC;
  } else if (t < BREATH_UP_SEC + BREATH_HOLD_HI) {
    // hold high
    v = 1.0;
  } else if (t < BREATH_UP_SEC + BREATH_HOLD_HI + BREATH_DOWN_SEC) {
    // ramp down
    v = 1.0 - (t - (BREATH_UP_SEC + BREATH_HOLD_HI)) / BREATH_DOWN_SEC;
  } else {
    // hold low
    v = 0.0;
  }

  uint8_t brightness = lerp8(BREATH_MIN, BREATH_MAX, v);
  fill_solid(leds, NUM_LEDS, CHSV(160, 200, brightness));  // e.g. purple hue=160
  FastLED.show();
}

void doOverrideFlash() {
  unsigned long now = millis();

  // toggle every FLASH_INTERVAL
  if (now - lastFlashToggle >= FLASH_INTERVAL) {
    lastFlashToggle = now;
    flashOn = !flashOn;
  }

  if (flashOn) {
    fill_solid(leds, NUM_LEDS, CRGB::Red);
  } else {
    FastLED.clear();
  }
  FastLED.show();

  // end override?
  if (now - overrideStartTime >= OVERRIDE_DURATION) {
    overrideActive = false;
    breathStart = now;  // restart breathing cycle
    Serial.println("‚è± override ended, resuming breathe");
  }
}

// ‚Äî‚Äî‚Äî LOOP ‚Äî‚Äî‚Äî
void loop() {
  if (overrideActive) {
    doOverrideFlash();
  } else {
    doBreathing();
  }
}
