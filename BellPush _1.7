#include <esp_now.h>
#include <WiFi.h>

// â€”â€”â€” CONFIG â€”â€”â€”
#define BELL_PIN        13     // your external bell button (GPIO13)
#define BOOT_PIN         0     // onboard BOOT button (GPIO0)
#define LED_PIN          2     // onboard LED

// put addresses of every esp32 this pushbutton will contact.
static const uint8_t cydMACs[][6] = {
  { 0xEC, 0x64, 0xC9, 0x93, 0xF5, 0xB0 },  // CYD #1
  { 0x14, 0x2B, 0x2F, 0xDA, 0x50, 0xC4 },   // CYD #2
  {0xFC, 0xF5, 0xC4, 0x26, 0x62, 0xEC } // breathe leds
};
const size_t NUM_CYDS = sizeof(cydMACs) / sizeof(cydMACs[0]);
const unsigned long MAX_AWAKE_TIME = 10000; // ms before forced sleep

// â€”â€”â€” STATE â€”â€”â€”
volatile bool resetReceived = false;

// â€”â€”â€” ESP-NOW RECEIVER â€”â€”â€”
void onDataRecv(const esp_now_recv_info_t* info, const uint8_t* data, int len) {
  if (len >= 5 && memcmp(data, "reset", 5) == 0) {
    // which CYD sent it?
    for (size_t i = 0; i < NUM_CYDS; i++) {
      if (memcmp(info->src_addr, cydMACs[i], 6) == 0) {
        Serial.printf("â—€ RESET received from CYD #%u\n", i+1);
        break;
      }
    }
    resetReceived = true;
  }
}

// â€”â€”â€” SEND BELL + SLEEP â€”â€”â€”
void sendBell() {
  Serial.println("ðŸ”” Sending BELL to all CYDsâ€¦");
  const uint8_t msg[] = { 'b','e','l','l','\0' };

  for (size_t i = 0; i < NUM_CYDS; i++) {
    esp_err_t res = esp_now_send(cydMACs[i], msg, sizeof(msg));
    Serial.printf("  â–¶ peer %u â†’ %s\n", i+1,
                  res == ESP_OK ? "OK" : String("ERR " + String(res)).c_str());
  }

  // flash LED as visual ack
  digitalWrite(LED_PIN, HIGH);
  delay(100);
  digitalWrite(LED_PIN, LOW);

  Serial.println("â± Going to deep sleep now");
  esp_deep_sleep_start();
}

// â€”â€”â€” SETUP & BOOT LOGIC â€”â€”â€”
void setup() {
  Serial.begin(115200);
  delay(50);
  pinMode(BELL_PIN, INPUT_PULLUP);
  pinMode(BOOT_PIN,  INPUT_PULLUP);
  pinMode(LED_PIN,   OUTPUT);

  // Report wake reason:
  esp_sleep_wakeup_cause_t cause = esp_sleep_get_wakeup_cause();
  switch (cause) {
    case ESP_SLEEP_WAKEUP_EXT0:
      Serial.println("ðŸ”„ Wakeup: BOOT button (EXT0)");
      break;
    case ESP_SLEEP_WAKEUP_EXT1:
      Serial.println("ðŸ”„ Wakeup: BELL button (EXT1)");
      break;
    case ESP_SLEEP_WAKEUP_UNDEFINED:
    default:
      Serial.println("ðŸ”„ Cold boot / manual reset");
      break;
  }

  // â€” Configure both wake sources â€”
  // EXT0 = single-pin (GPIO0 low)
  esp_sleep_enable_ext0_wakeup(GPIO_NUM_0, 0);
  Serial.println("  â†ª EXT0 wake on BOOT (GPIO0)");

  // EXT1 = â€œALL_LOWâ€ on mask; here mask is only GPIO13
  esp_sleep_enable_ext1_wakeup(1ULL << BELL_PIN, ESP_EXT1_WAKEUP_ALL_LOW);
  Serial.println("  â†ª EXT1 wake on BELL (GPIO13)");

  // â€” Init Wi-Fi & ESP-NOW â€”
  WiFi.mode(WIFI_STA);
  WiFi.disconnect();

  if (esp_now_init() != ESP_OK) {
    Serial.println("âŒ ESP-NOW init failed");
    while (true) { delay(1000); }
  }
  esp_now_register_recv_cb(onDataRecv);

  // â€” Register peers â€”
  for (size_t i = 0; i < NUM_CYDS; i++) {
    esp_now_peer_info_t peer = {};
    memcpy(peer.peer_addr, cydMACs[i], 6);
    peer.channel = 0;
    peer.encrypt = false;
    if (!esp_now_is_peer_exist(cydMACs[i])) {
      if (esp_now_add_peer(&peer) == ESP_OK) {
        Serial.printf("âœ… peer %u added\n", i+1);
      } else {
        Serial.printf("âŒ peer %u add failed\n", i+1);
      }
    }
  }

  Serial.println("âœ… BellPush ready (waiting for buttonâ€¦)");
}

// â€”â€”â€” MAIN LOOP â€”â€”â€”
void loop() {
  static bool lastState = HIGH;
  bool cur = digitalRead(BELL_PIN);

  // Detect falling edge on BELL pin or BOOT pin
  if (lastState == HIGH && cur == LOW) {
    Serial.println("ðŸ”˜ BELL pressed");
    sendBell();
  }
  lastState = cur;

  // Also allow BOOT pin to send same message:
  if (digitalRead(BOOT_PIN) == LOW) {
    Serial.println("ðŸ”˜ BOOT pressed");
    sendBell();
  }

  delay(50);
}
